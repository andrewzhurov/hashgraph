
* TODO dynamic membership
** DONE initial membership
** TODO initial membership UI
** DONE issue invites
** TODO issue invites UI (as of some member)

* TODO stake
** TODO initial stake UI
** DONE share stake on invite
** DONE conclude with stake-map
** DONE witness with stake-map

* DONE issue events in parallel

* DONE issue events on scroll
** DONE issue events when scroll is close to end

* DONE viz votes

* DONE viz voting concluded

* DONE viz round concluded

* DONE viz order of events

* TODO perhaps uniform init-db creation

* TODO efficient render
** DONE render view area + a bit around
Turned out to be slower than allowing browser to handle it.
Just rendering the whole SVG now.
UPD: re-calculation of old events with novel cr been costly,
implemented in-view events render.
Perhaps old events can be simply memoized.
But then they also add overhead of tracing whether they're inspected.
Overall, it becomes more efficient to render only in-view ones.
** DONE profile code
Added application-level profiling & viz.
** DONE issuing invites on infini-events slows down a ton
Switched to issuing in batches, outside render fn.
** DONE re-rendering refs is meh
Switched to rendering in-view events and ones directly atop and below (for refs).
** DONE re-rendering all other stuff is meh
Switched to rendering in-view events and ones directly atop and below (for refs).
** DONE perhaps increase efficiency of event->learned-events
As this logic is reused for cr witnesses, voting witnesses, whether received event, middle learned events. (last two use the same mem)
** DONE switch to transients as fn mem from atoms
Should be faster now.
** TODO parallelize execution
Web Workers to the resque.
*** TODO learn about Web Workers
**** can use [[https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas][OffscreenCanvas]] to render in a Worker
**** TODO how to pass data in/out?
***** as [[https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects][Transferables]], efficiently
***** TODO can we use shared data source between Workers and main thread?
**** TODO how to memoize from a worker?
*** TODO see how cljs-thread can be used
*** TODO run core logic in parallel
*** TODO run core logic out of the main thread
** TODO perhaps performance drops as lookups from mem get ever more costly
These lookups are mostly within the cr context, so we can try doing lookups within cr context.
*** solution: do hierarchical lookup, where cr is first
**** con: will slow down overall performance due to hierarchical lookup everywhere
**** con: will slow down as more cr come
*** solution: bind mem for cr in code, have all fns store their mems under it.
cr -> fn-name -> fn-args -> vals
** TODO inspector got slow on trace display
*** TODO perhaps do not trace from mem resolution
*** TODO perhaps do not render inputs and args if they don't even fit
*** TODO perhaps don't render traces that are < 1 pixel wide
Or don't collect traces that are instanteneous.
Although both of that hinders insight.
Rendering them is alright, thei'r inputs and args display are costly.
*** TODO input and result is not that valuable to display ALL THE TIME
Make their display a result of user's intent.
E.g., on hover.
** TODO inspector can scale via css, avoiding costly tree recompute
Use a class to scale, like .scale-2x on root flame trace.
** TODO inspector to scroll viz to peeked events
*** perhaps Browser's search can be used to go through matched results

* DONE fix inspector
* DONE pass top evt and not witness
* DONE fix stuck on 3rd round
* DONE add mod keys to inspector
** DONE shift to peek on hover
** DONE shift to inspect on click
** DONE expand on plain click
* DONE add flip as right-click option
* TODO make it easier to uninspect
* TODO show stake-map as of prev cr
* TODO trace as meta on returned values
** cons: primitive values won't be traced
*** solution: wrap returned values in trace object
** cons: on error won't see trace
*** solution: errors as data
** alternatively: store trace into inspector's log, use it as mem as well
* TODO inspector to show seq's lazily
As there can be > 1k elements, showing them eagerly is not needed and damm not performant.

* objectives
** understand the algo to see how it can be applied in NG
** to make algorithm understandable
*** things to explain:
**** members
***** members connectivity
***** member's stake
***** events
****** event tx
******* share stake tx
******** show how without stake it's possible to overwhelm with puppet-socks members
******** show how stake-map affects: round, witness, votes.
******* register on-the-repo tx
******** i.e., smart contract / FSM transition
******** trigger registered on-the-repo tx
******* arbitrary determenistic tx
******** in IPVM
********* as SPARQL with oxigraph
****** event other-parent
****** event self-parent
******* forks
******** sees
********* strongly sees
********** round
*********** witnesses
************ votes
************* concludes voting
************** infamous witness
************** famous witness
*************** unique famous witness
**************** round concluded
***************** event round received
****************** event received time
******************* learners events
******************** their median ones
********************* median creation time
******************* event order by round received + received time
****************** custom CRS
******************* event order by round received + custom CRS
******************** by round received + received time
******************** by round received + custom CRS
************ receives votes


* possible further work
** switch to garden color data model
*** add color viz to inspector
** make algorithm viz mesmerizing
** make interactive learning
*** in form of a saper game
**** with progress saved
**** gets more difficult as you go
**** leaderboard
*** in form of a MCQ
** resistance to inactive members
*** e.g., remove their stake from acceptance threshold
** receive txes by a random unique famous witness
*** as [[https://hyp.is/i7oToKStEe6K2yuNUmkCBA/www.semanticscholar.org/reader/a40fa41177feb0a9aa59fff45caa4cfa7058fd51][is done in DAG-Rider]]
*** take more inspiration from DAG-Rider
*** take inspiration from other DAG-based blockchains
** delegated stake
** many other-parents
** XOX
** AST
*** for concluding rounds eval only the AST of share stake txes
*** share with peers only txes that they are interested in
**** e.g., that you know are on top of their ASTs
**** perhaps have dynamic stake on a tx, based on who's collaborating on it
** consensus on demand
*** sharding / dynamic quorum pools
** compaction / snapshots
** bloom filter for efficient sync
*** (up to a snapshot) or up to received txes (hash of that tx + proofs is enough to build on top of it)
** add libp2p for real peers to talk
*** an example app
**** what's the use-case with high degree of conflict and p2p?
***** asset transfer
**** what's the use-case with need of total order?
